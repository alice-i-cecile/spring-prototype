<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Spring Prototype</title>
    <link href="/stylesheets/screen.css" media="all" rel="stylesheet" type="text/css"/>
    <script language="javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js" type="text/javascript"></script><script language="javascript" src="javascripts/jquery.hotkeys.js" type="text/javascript"></script><script language="javascript" src="javascripts/key_status.js" type="text/javascript"></script><script language="javascript" src="javascripts/util.js" type="text/javascript"></script><script language="javascript" src="javascripts/sprite.js" type="text/javascript"></script><script language="javascript" src="javascripts/sound.js" type="text/javascript"></script>
  </head>
  <body>
    <h1>Spring Prototype</h1>
    <script type='text/javascript'>
      //<![CDATA[
        var CANVAS_WIDTH = 1600;
        var CANVAS_HEIGHT = CANVAS_WIDTH*9/16;

        var PM_ALPHA = 0.8;
        var SPRING_ALPHA = 0.5;
        var PM_SIZE = 3;

        var FPS = 60;
        var TIMESTEP = 1 / FPS;

        var NUM_PM = 11;
        // One of:
        //  - "RECTANGLE"
        //  - "CIRCLE"
        //  - "RING"
        //  - "UNIFORM_RING"
        var SPAWN_FORMATION = "UNIFORM_RING";
        var SPAWN_SIZE = 0.5;

        var GRAVITY = 0.1;
        var CONTROL_FORCE = 1;
        var DRAG_COEFFICIENT = 0.001;
        var ELASTICITY = 1;
        var PM_MASS = 1;

        var SPRING_STIFFNESS = 500;
        // Array denotes connect k-neighbours; use keys to show connections
        // e.g. [1,2] connects neighbours and adjacent
        // Number means to form fraction of possible connections at random
        // Use n_connections / (NUM_PM * (NUM_PM - 1)) for scale invariance
        var CONNECTIVITY = [1,2,3];

        var canvasElement = $("<canvas width='" + CANVAS_WIDTH +
          "' height='" + CANVAS_HEIGHT + "'></canvas");
        var canvas = canvasElement.get(0).getContext("2d");
        canvasElement.appendTo('body');

        // TODO: Change to requestAnimationFrame() for performance
        setInterval(function() {
          update();
          draw();
        }, 1000 * TIMESTEP);

        pointMasses = []
        class pointMass {
          constructor (x, y){
            this.x = x;
            this.y = y;

            this.v_x = 0;
            this.v_y = 0;

            this.a_x = 0;
            this.a_y = 0;

            this.CONTROL_FORCE = CONTROL_FORCE;
            this.drag_coefficient = DRAG_COEFFICIENT;
            this.elasticity = ELASTICITY;
            this.mass = PM_MASS;

            pointMasses.push(this);
          }

          draw() {
            canvas.beginPath();
            canvas.arc(this.x, this.y,
              PM_SIZE,
              0, 2*Math.PI);
            canvas.fill();
          }
        }

        // Create point masses at random
        // TODO: change to case statement
        if (SPAWN_FORMATION == "RECTANGLE"){
          minSpawnX = CANVAS_WIDTH/2  -  CANVAS_WIDTH*SPAWN_SIZE/2;
          minSpawnY = CANVAS_HEIGHT/2 - CANVAS_HEIGHT*SPAWN_SIZE/2;

          for (var i = 1; i <= NUM_PM; i++){
            new pointMass(minSpawnX + Math.random() * CANVAS_WIDTH  * SPAWN_SIZE,
                          minSpawnY + Math.random() * CANVAS_HEIGHT * SPAWN_SIZE);
          }
        } else if (SPAWN_FORMATION == "CIRCLE"){
          center_x = CANVAS_WIDTH/2;
          center_y = CANVAS_HEIGHT/2;
          max_radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
          radius = max_radius * SPAWN_SIZE;

          for (var i = 1; i <= NUM_PM; i++){
            r_i = Math.random() * radius;
            theta_i = Math.random() * 2 * Math.PI;
            x_i = center_x + r_i*Math.cos(theta_i);
            y_i = center_y + r_i*Math.sin(theta_i);

            new pointMass(x_i, y_i);
          }
        } else if (SPAWN_FORMATION == "RING"){
          center_x = CANVAS_WIDTH/2;
          center_y = CANVAS_HEIGHT/2;
          max_radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
          radius = max_radius * SPAWN_SIZE;

          for (var i = 1; i <= NUM_PM; i++){
            theta_i = Math.random() * 2 * Math.PI;
            x_i = center_x + radius*Math.cos(theta_i);
            y_i = center_y + radius*Math.sin(theta_i);

            new pointMass(x_i, y_i);
          }
        } else if (SPAWN_FORMATION == "UNIFORM_RING"){
          center_x = CANVAS_WIDTH/2;
          center_y = CANVAS_HEIGHT/2;
          max_radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
          radius = max_radius * SPAWN_SIZE;

          for (var i = 1; i <= NUM_PM; i++){
            theta_i = i / NUM_PM * 2 * Math.PI;
            x_i = center_x + radius*Math.cos(theta_i);
            y_i = center_y + radius*Math.sin(theta_i);

            new pointMass(x_i, y_i);
          }
        }

        connectivityMatrix = createArray(NUM_PM, NUM_PM);

        // CONNECTIVITY needs to be complemented with NUM_PM - CONNECTIVITY
        // Ensures proper looping
        if (CONNECTIVITY instanceof Array){
          CONNECTIVITY = CONNECTIVITY.concat(CONNECTIVITY.map(x => NUM_PM - x));
        }

        for (var i = 0; i <= NUM_PM - 1; i++){
          for (var j = 0; j <= NUM_PM - 1; j++){
            // Use only the upper triangular matrix to ensure single connections
            if (i > j){
              if (CONNECTIVITY instanceof Array){
                // Connect k-neighbours
                // inArray returns -1 when not found
                if (jQuery.inArray((i-j).mod(NUM_PM), CONNECTIVITY) != -1){
                  connectivityMatrix[i][j] = 1;
                } else {
                  connectivityMatrix[i][j] = 0;
                }
              // Random connections
              } else if (Math.random() < CONNECTIVITY) {
                connectivityMatrix[i][j] = 1;
              } else {
                connectivityMatrix[i][j] = 0;
              }
            } else {
              connectivityMatrix[i][j] = 0;
            }
          }
        }

        springs = [];
        class spring {
          constructor (pm_1, pm_2){
            this.pm_1 = pm_1;
            this.pm_2 = pm_2;

            this.length = Math.sqrt((pm_2.x - pm_1.x)*(pm_2.x - pm_1.x) +
                                    (pm_2.y - pm_1.y)*(pm_2.y - pm_1.y)) /
                          CANVAS_WIDTH;

            this.stiffness = SPRING_STIFFNESS;

            springs.push(this);
          }

          draw() {
            canvas.beginPath();
            canvas.moveTo(this.pm_1.x, this.pm_1.y);
            canvas.lineTo(this.pm_2.x, this.pm_2.y);
            canvas.stroke();
          }
        }

        // Create springs based on connectivityMatrix
        for (var i = 0; i <= NUM_PM - 1; i++){
          for (var j = 0; j <= NUM_PM - 1; j++){
            if (connectivityMatrix[i][j] == 1){
              new spring(pointMasses[i], pointMasses[j]);
            }
          }
        }

        function update() {

          // Reset acceleration for the timestep
          pointMasses.forEach(function(pm){
            pm.a_x = 0;
            pm.a_y = 0;
          })

          springs.forEach(function(sp){
            forces(sp);
          })

          pointMasses.forEach(function(pm){
            controls(pm);

            physics(pm);

            check_collisions(pm);
          })

        }

        function draw() {
          canvas.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          canvas.globalAlpha = 1;
          canvas.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          canvas.font="20px Courier";
          canvas.fillText(`FPS: ${FPS}`, 0.9*CANVAS_WIDTH, 0.05*CANVAS_HEIGHT);

          canvas.globalAlpha = PM_ALPHA;
          pointMasses.forEach(function(pm){
            pm.draw();
          })

          canvas.globalAlpha = SPRING_ALPHA;
          springs.forEach(function(sp){
            sp.draw();
          })
        }

        function forces(sp){
          // Hooke's law
          // TODO: add dampened springs
          deltaX = (sp.pm_2.x - sp.pm_1.x) / CANVAS_WIDTH;
          deltaY = (sp.pm_2.y - sp.pm_1.y) / CANVAS_WIDTH;
          dist =  Math.sqrt(deltaX*deltaX + deltaY*deltaY);
          // If distance becomes zero then object disappears
          dist = Math.max(dist, 1e-6);

          F_total = -1 * sp.stiffness * (sp.length - dist);
          F_x = F_total * deltaX / dist;
          F_y = F_total * deltaY / dist;

          sp.pm_1.a_x += F_x / sp.pm_1.mass;
          sp.pm_2.a_x -= F_x / sp.pm_2.mass;

          sp.pm_1.a_y += F_y / sp.pm_1.mass;
          sp.pm_2.a_y -= F_y / sp.pm_2.mass;

        }

        function controls(pm) {
          // Correct for faster diagonal movement
          // Sum of vectors must be same as in case where moving along one axis
          // so each is scaled by 1/sqrt(2)
          step_CONTROL_FORCE = pm.CONTROL_FORCE;

          if ((keydown.left || keydown.right) && (keydown.up || keydown.down)){
            step_CONTROL_FORCE *= 0.70710678118;
          }

          // Movement controls
          if(keydown.left) {
            pm.a_x -= step_CONTROL_FORCE / pm.mass;
          }

          if(keydown.right) {
            pm.a_x += step_CONTROL_FORCE / pm.mass;
          }

          if(keydown.up) {
            pm.a_y -= step_CONTROL_FORCE / pm.mass;
          }

          if(keydown.down) {
            pm.a_y += step_CONTROL_FORCE / pm.mass;
          }
        }

        // TODO: abstract more cleanly
        // to allow vectorization and easier scale-independence
        function physics(pm){
          // Gravity
          pm.a_y += GRAVITY;

          // Drag
          pm.a_x -= pm.v_x * (1 - pm.drag_coefficient);
          pm.a_y -= pm.v_y * (1 - pm.drag_coefficient);

          // Movement
          pm.v_x += pm.a_x * TIMESTEP;
          pm.v_y += pm.a_y * TIMESTEP;

          pm.x += pm.v_x * TIMESTEP * CANVAS_WIDTH;
          pm.y += pm.v_y * TIMESTEP * CANVAS_WIDTH;
        }

        function check_collisions(pm) {
          if (pm.x < 0 || pm.x > CANVAS_WIDTH){
            pm.v_x *= -pm.elasticity;
          }

          if (pm.y < 0 || pm.y > CANVAS_HEIGHT){
            pm.v_y *= -pm.elasticity;
          }

          // Enforce existence in game area by rebounding
          if (pm.x < 0){
            pm.x = 0 - pm.elasticity*(pm.x - 0);
          } else if (pm.x > CANVAS_WIDTH){
            pm.x = CANVAS_WIDTH - pm.elasticity*(pm.x - CANVAS_WIDTH);
          }

          if (pm.y < 0){
            pm.y = 0 - pm.elasticity*(pm.y - 0);
          } else if (pm.y > CANVAS_HEIGHT){
            pm.y = CANVAS_HEIGHT - pm.elasticity*(pm.y - CANVAS_HEIGHT);
          }
        }

      //]]>
    </script>
  </body>
</html>
