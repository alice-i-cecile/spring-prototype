<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Spring Prototype</title>
    <link href="/stylesheets/screen.css" media="all" rel="stylesheet" type="text/css"/>
    <script language="javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js" type="text/javascript"></script><script language="javascript" src="javascripts/jquery.hotkeys.js" type="text/javascript"></script><script language="javascript" src="javascripts/key_status.js" type="text/javascript"></script><script language="javascript" src="javascripts/util.js" type="text/javascript"></script><script language="javascript" src="javascripts/sprite.js" type="text/javascript"></script><script language="javascript" src="javascripts/sound.js" type="text/javascript"></script>
  </head>
  <body>
    <h1>Spring Prototype</h1>
    <script type='text/javascript'>
      //<![CDATA[
        var CANVAS_WIDTH = 1600;
        var CANVAS_HEIGHT = CANVAS_WIDTH*9/16;

        var PM_ALPHA = 0.8;
        var SPRING_ALPHA = 0.2;
        var PM_SIZE = 3;

        var FPS = 60;
        var TIMESTEP = 1 / FPS;

        var NUM_PM = 1000;
        var SPAWN_FORMATION = "RING";
        var SPAWN_SIZE = 0.5;

        var GRAVITY = 0.4;
        var CONTROL_FORCE = 1;
        var DRAG_COEFFICIENT = 0.02;
        var ELASTICITY = 0.9;
        var PM_MASS = 1;

        var SPRING_STIFFNESS = 100;
        // Use n_connections / (NUM_PM * (NUM_PM - 1)) for scale invariance
        var CONNECTIVITY = 10000 / (NUM_PM * (NUM_PM - 1));


        var canvasElement = $("<canvas width='" + CANVAS_WIDTH +
          "' height='" + CANVAS_HEIGHT + "'></canvas");
        var canvas = canvasElement.get(0).getContext("2d");
        canvasElement.appendTo('body');

        // TODO: Change to requestAnimationFrame() for performance
        setInterval(function() {
          update();
          draw();
        }, 1000 * TIMESTEP);

        pointMasses = []
        class pointMass {
          constructor (x, y){
            this.x = x;
            this.y = y;

            this.v_x = 0;
            this.v_y = 0;

            this.a_x = 0;
            this.a_y = 0;

            this.CONTROL_FORCE = CONTROL_FORCE;
            this.drag_coefficient = DRAG_COEFFICIENT;
            this.elasticity = ELASTICITY;
            this.mass = PM_MASS;

            pointMasses.push(this);
          }

          draw() {
            canvas.beginPath();
            canvas.arc(this.x, this.y,
              PM_SIZE,
              0, 2*Math.PI);
            canvas.fill();
          }
        }

        // Create point masses at random
        if (SPAWN_FORMATION == "RECTANGLE"){
          minSpawnX = CANVAS_WIDTH/2  -  CANVAS_WIDTH*SPAWN_SIZE/2;
          minSpawnY = CANVAS_HEIGHT/2 - CANVAS_HEIGHT*SPAWN_SIZE/2;

          for (var i = 1; i <= NUM_PM; i++){
            new pointMass(minSpawnX + Math.random() * CANVAS_WIDTH  * SPAWN_SIZE,
                          minSpawnY + Math.random() * CANVAS_HEIGHT * SPAWN_SIZE);
          }
        } else if (SPAWN_FORMATION == "CIRCLE"){
          center_x = CANVAS_WIDTH/2;
          center_y = CANVAS_HEIGHT/2;
          max_radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
          radius = max_radius * SPAWN_SIZE;

          for (var i = 1; i <= NUM_PM; i++){
            r_i = Math.random() * radius;
            theta_i = Math.random() * 2 * Math.PI;
            x_i = center_x + r_i*Math.cos(theta_i);
            y_i = center_y + r_i*Math.sin(theta_i);

            new pointMass(x_i, y_i);
          }
        } else if (SPAWN_FORMATION == "RING"){
          center_x = CANVAS_WIDTH/2;
          center_y = CANVAS_HEIGHT/2;
          max_radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
          radius = max_radius * SPAWN_SIZE;

          for (var i = 1; i <= NUM_PM; i++){
            theta_i = Math.random() * 2 * Math.PI;
            x_i = center_x + radius*Math.cos(theta_i);
            y_i = center_y + radius*Math.sin(theta_i);

            new pointMass(x_i, y_i);
          }
        }
        // TODO: add uniform ring formation


        // TODO: add option to connect neighbours and k-off neighbours instead
        connectivityMatrix = createArray(NUM_PM, NUM_PM);

        // Set the upper triangular matrix to 1
        // Denotes fully singly connected graph
        for (var i = 0; i <= NUM_PM - 1; i++){
          for (var j = 0; j <= NUM_PM - 1; j++){
            if (i > j && Math.random() < CONNECTIVITY){
              connectivityMatrix[i][j] = 1;
            } else {
              connectivityMatrix[i][j] = 0;
            }
          }
        }

        springs = [];
        class spring {
          constructor (pm_1, pm_2){
            this.pm_1 = pm_1;
            this.pm_2 = pm_2;

            this.length = Math.sqrt((pm_2.x - pm_1.x)*(pm_2.x - pm_1.x) +
                                    (pm_2.y - pm_1.y)*(pm_2.y - pm_1.y)) /
                          CANVAS_WIDTH;

            this.stiffness = SPRING_STIFFNESS;

            springs.push(this);
          }

          draw() {
            canvas.beginPath();
            canvas.moveTo(this.pm_1.x, this.pm_1.y);
            canvas.lineTo(this.pm_2.x, this.pm_2.y);
            canvas.stroke();
          }
        }

        // Create springs based on connectivityMatrix
        for (var i = 0; i <= NUM_PM - 1; i++){
          for (var j = 0; j <= NUM_PM - 1; j++){
            if (connectivityMatrix[i][j] == 1){
              new spring(pointMasses[i], pointMasses[j]);
            }
          }
        }

        function update() {

          // Reset acceleration for the timestep
          pointMasses.forEach(function(pm){
            pm.a_x = 0;
            pm.a_y = 0;
          })

          springs.forEach(function(sp){
            forces(sp);
          })

          pointMasses.forEach(function(pm){
            controls(pm);

            physics(pm);

            check_collisions(pm);
          })

        }

        function draw() {
          canvas.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          canvas.globalAlpha = 1;
          canvas.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          canvas.font="20px Courier";
          canvas.fillText(`FPS: ${FPS}`, 0.9*CANVAS_WIDTH, 0.05*CANVAS_HEIGHT);

          canvas.globalAlpha = PM_ALPHA;
          pointMasses.forEach(function(pm){
            pm.draw();
          })

          canvas.globalAlpha = SPRING_ALPHA;
          springs.forEach(function(sp){
            sp.draw();
          })
        }

        function forces(sp){
          // Hooke's law
          // TODO: add dampened springs
          deltaX = (sp.pm_2.x - sp.pm_1.x) / CANVAS_WIDTH;
          deltaY = (sp.pm_2.y - sp.pm_1.y) / CANVAS_WIDTH;
          dist =  Math.sqrt(deltaX*deltaX + deltaY*deltaY);
          // If distance becomes zero then object disappears
          dist = Math.max(dist, 1e-6);

          F_total = -1 * sp.stiffness * (sp.length - dist);
          F_x = F_total * deltaX / dist;
          F_y = F_total * deltaY / dist;

          sp.pm_1.a_x += F_x / sp.pm_1.mass;
          sp.pm_2.a_x -= F_x / sp.pm_2.mass;

          sp.pm_1.a_y += F_y / sp.pm_1.mass;
          sp.pm_2.a_y -= F_y / sp.pm_2.mass;

        }

        function controls(pm) {
          // Correct for faster diagonal movement
          // Sum of vectors must be same as in case where moving along one axis
          // so each is scaled by 1/sqrt(2)
          step_CONTROL_FORCE = pm.CONTROL_FORCE;

          if ((keydown.left || keydown.right) && (keydown.up || keydown.down)){
            step_CONTROL_FORCE *= 0.70710678118;
          }

          // Movement controls
          if(keydown.left) {
            pm.a_x -= step_CONTROL_FORCE / pm.mass;
          }

          if(keydown.right) {
            pm.a_x += step_CONTROL_FORCE / pm.mass;
          }

          if(keydown.up) {
            pm.a_y -= step_CONTROL_FORCE / pm.mass;
          }

          if(keydown.down) {
            pm.a_y += step_CONTROL_FORCE / pm.mass;
          }
        }

        // TODO: abstract more cleanly
        // to allow vectorization and easier scale-independence
        function physics(pm){
          // Gravity
          pm.a_y += GRAVITY;

          // Drag
          pm.a_x -= pm.v_x * (1 - pm.drag_coefficient);
          pm.a_y -= pm.v_y * (1 - pm.drag_coefficient);

          // Movement
          pm.v_x += pm.a_x * TIMESTEP;
          pm.v_y += pm.a_y * TIMESTEP;

          pm.x += pm.v_x * TIMESTEP * CANVAS_WIDTH;
          pm.y += pm.v_y * TIMESTEP * CANVAS_WIDTH;
        }

        function check_collisions(pm) {
          if (pm.x < 0 || pm.x > CANVAS_WIDTH){
            pm.v_x *= -pm.elasticity;
          }

          if (pm.y < 0 || pm.y > CANVAS_HEIGHT){
            pm.v_y *= -pm.elasticity;
          }

          // Enforce existence in game area
          // TODO: Conserve extra energy to prevent weird syncing
          pm.x = pm.x.clamp(0, CANVAS_WIDTH);
          pm.y = pm.y.clamp(0, CANVAS_HEIGHT);
        }

      //]]>
    </script>
  </body>
</html>
