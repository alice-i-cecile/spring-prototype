<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>Spring Prototype</title>
    <link href="/stylesheets/screen.css" media="all" rel="stylesheet" type="text/css"/>
    <script language="javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js" type="text/javascript"></script><script language="javascript" src="javascripts/jquery.hotkeys.js" type="text/javascript"></script><script language="javascript" src="javascripts/key_status.js" type="text/javascript"></script><script language="javascript" src="javascripts/util.js" type="text/javascript"></script><script language="javascript" src="javascripts/sprite.js" type="text/javascript"></script><script language="javascript" src="javascripts/sound.js" type="text/javascript"></script>
  </head>
  <body>
    <h1>Spring Prototype</h1>
    <script type='text/javascript'>
      //<![CDATA[
        var CANVAS_WIDTH = 1600;
        var CANVAS_HEIGHT = CANVAS_WIDTH*9/16;

        var PM_ALPHA = 0.8;
        var SPRING_ALPHA = 0.5;
        var PM_SIZE = 3;

        var FPS = 60;
        var TIMESTEP = 1 / FPS;

        var NUM_PM = 1000;
        var SPAWN_FORMATION = "UNIFORM_RING";
        var SPAWN_SIZE = 0.5;

        var GRAVITY = 0;
        var CONTROL_FORCE = 1;
        var DRAG_COEFFICIENT = 0.4;
        var ELASTICITY = 0.9;
        var PM_MASS = 1;

        var SPRING_STIFFNESS = 10;
        var RELATIVE_STRENGTH = 0.2;
        var CONNECTIVITY = [1,2,3,100, 500];

        class pointMass {
          constructor (x, y){
            this.x = x;
            this.y = y;

            this.v_x = 0;
            this.v_y = 0;

            this.a_x = 0;
            this.a_y = 0;

            this.F_x = 0;
            this.F_y = 0;

            this.CONTROL_FORCE = CONTROL_FORCE;
            this.drag_coefficient = DRAG_COEFFICIENT;
            this.elasticity = ELASTICITY;
            this.mass = PM_MASS;

            pointMasses.push(this);
          }

          draw() {
            canvas.beginPath();
            canvas.arc(this.x, this.y,
                       PM_SIZE,
                       0, 2*Math.PI);
            canvas.fill();
          }
        }

        class spring {
          constructor (pm_1, pm_2){
            this.pm_1 = pm_1;
            this.pm_2 = pm_2;

            this.deltaX = (this.pm_2.x - this.pm_1.x)/CANVAS_WIDTH;
            this.deltaY = (this.pm_2.y - this.pm_1.y)/CANVAS_WIDTH;
            this.length = this.compute_length(); // resting distance
            this.dist = this.length; // current distance

            this.stiffness = SPRING_STIFFNESS;
            this.strength = this.stiffness * RELATIVE_STRENGTH;

            springs.push(this);
          }

          draw() {
            canvas.beginPath();
            canvas.moveTo(this.pm_1.x, this.pm_1.y);
            canvas.lineTo(this.pm_2.x, this.pm_2.y);
            canvas.stroke();
          }

          compute_length() {
            var dist = Math.sqrt(this.deltaX*this.deltaX + this.deltaY*this.deltaY);
            // If distance becomes zero then object disappears
            dist = Math.max(dist, 1e-6);

            return dist;
          }

          springForce() {
            // Hooke's law
            var force = {};
            force.total = -1 * this.stiffness * (this.length - this.dist);
            force.x = force.total * this.deltaX / this.dist;
            force.y = force.total * this.deltaY / this.dist;

            this.pm_1.F_x += force.x;
            this.pm_2.F_x -= force.x;

            this.pm_1.F_y += force.y;
            this.pm_2.F_y -= force.y;
          }

          muscle(){
            // Relative strength is the fraction of the lenth the muscle can change
            var force = {};
            force.total = this.strength * this.length;

            force.x = force.total * this.deltaX / this.dist;
            force.y = force.total * this.deltaY / this.dist;

            console.log(force);
            return force;
          }

          contract(){
            var force = this.muscle()
            this.pm_1.F_x += force.x;
            this.pm_2.F_x -= force.x;

            this.pm_1.F_y += force.y;
            this.pm_2.F_y -= force.y;
          }

          expand(){
            var force = this.muscle()
            this.pm_1.F_x -= force.x;
            this.pm_2.F_x += force.x;

            this.pm_1.F_y -= force.y;
            this.pm_2.F_y += force.y;
          }
        }

        // Create canvas
        var canvasElement = $("<canvas width='" + CANVAS_WIDTH +
          "' height='" + CANVAS_HEIGHT + "'></canvas");
        var canvas = canvasElement.get(0).getContext("2d");
        canvasElement.appendTo('body');

        // Initialize gameplay loop
        initialize();

        function initialize(){

          // Initialize object lists
          pointMasses = [];
          springs = [];

          // Create point masses at random
          // TODO: change to case statement
          if (SPAWN_FORMATION == "RECTANGLE"){
            minSpawnX = CANVAS_WIDTH/2  -  CANVAS_WIDTH*SPAWN_SIZE/2;
            minSpawnY = CANVAS_HEIGHT/2 - CANVAS_HEIGHT*SPAWN_SIZE/2;

            for (var i = 1; i <= NUM_PM; i++){
              new pointMass(minSpawnX + Math.random() * CANVAS_WIDTH  * SPAWN_SIZE,
                            minSpawnY + Math.random() * CANVAS_HEIGHT * SPAWN_SIZE);
            }
          } else if (SPAWN_FORMATION == "CIRCLE"){
            center_x = CANVAS_WIDTH/2;
            center_y = CANVAS_HEIGHT/2;
            maxRadius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
            radius = maxRadius * SPAWN_SIZE;

            for (var i = 1; i <= NUM_PM; i++){
              r_i = Math.random() * radius;
              theta_i = Math.random() * 2 * Math.PI;
              x_i = center_x + r_i*Math.cos(theta_i);
              y_i = center_y + r_i*Math.sin(theta_i);

              new pointMass(x_i, y_i);
            }
          } else if (SPAWN_FORMATION == "RING"){
            center_x = CANVAS_WIDTH/2;
            center_y = CANVAS_HEIGHT/2;
            max_radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
            radius = max_radius * SPAWN_SIZE;

            for (var i = 1; i <= NUM_PM; i++){
              theta_i = Math.random() * 2 * Math.PI;
              x_i = center_x + radius*Math.cos(theta_i);
              y_i = center_y + radius*Math.sin(theta_i);

              new pointMass(x_i, y_i);
            }
          } else if (SPAWN_FORMATION == "UNIFORM_RING"){
            center_x = CANVAS_WIDTH/2;
            center_y = CANVAS_HEIGHT/2;
            maxRadius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 2;
            radius = maxRadius * SPAWN_SIZE;

            for (var i = 1; i <= NUM_PM; i++){
              theta_i = i / NUM_PM * 2 * Math.PI;
              x_i = center_x + radius*Math.cos(theta_i);
              y_i = center_y + radius*Math.sin(theta_i);

              new pointMass(x_i, y_i);
            }
          }

          connectivityMatrix = createArray(NUM_PM, NUM_PM);

          // CONNECTIVITY needs to be complemented with NUM_PM - CONNECTIVITY
          // Ensures proper looping
          if (CONNECTIVITY instanceof Array){
            CONNECTIVITY = CONNECTIVITY.concat(CONNECTIVITY.map(x => NUM_PM - x));
          }

          // TODO: cleanup logic
          for (var i = 0; i <= NUM_PM - 1; i++){
            for (var j = 0; j <= NUM_PM - 1; j++){
              // Use only the upper triangular matrix to ensure single connections
              if (i > j){
                if (CONNECTIVITY instanceof Array){
                  // Connect k-neighbours
                  // inArray returns -1 when not found
                  if (jQuery.inArray((i-j).mod(NUM_PM), CONNECTIVITY) != -1){
                    connectivityMatrix[i][j] = 1;
                  } else {
                    connectivityMatrix[i][j] = 0;
                  }
                // Random connections
                } else if (Math.random() < CONNECTIVITY) {
                  connectivityMatrix[i][j] = 1;
                } else {
                  connectivityMatrix[i][j] = 0;
                }
              } else {
                connectivityMatrix[i][j] = 0;
              }
            }
          }

          // Create springs based on connectivityMatrix
          for (var i = 0; i <= NUM_PM - 1; i++){
            for (var j = 0; j <= NUM_PM - 1; j++){
              if (connectivityMatrix[i][j] == 1){
                new spring(pointMasses[i], pointMasses[j]);
              }
            }
          }

          // Main gameplay loop
          // TODO: Change to requestAnimationFrame() for performance
          setInterval(function() {
            update();
            draw();
          }, 1000 * TIMESTEP);
        }

        function update() {
          // Reset forces and acceleration for the timestep
          pointMasses.forEach(function(pm){
            pm.F_x = 0;
            pm.F_y = 0;
            pm.a_x = 0;
            pm.a_y = 0;
          })

          // Apply forces from springs
          springs.forEach(function(sp){

            // Update distances
            sp.deltaX = (sp.pm_2.x - sp.pm_1.x)/CANVAS_WIDTH;
            sp.deltaY = (sp.pm_2.y - sp.pm_1.y)/CANVAS_WIDTH;
            sp.dist = sp.compute_length();

            sp.springForce();

            // Muscle controls
            if (keydown.space){
              sp.expand();
            }

            if (keydown.ctrl){
              sp.contract();
            }
          })

          // Apply point specific forces
          pointMasses.forEach(function(pm){
            controls(pm);

            physics(pm);
          })

          // Apply kinematics
          pointMasses.forEach(function(pm){
            pm.a_x = pm.F_x / pm.mass;
            pm.a_y = pm.F_y / pm.mass;

            pm.v_x += pm.a_x * TIMESTEP;
            pm.v_y += pm.a_y * TIMESTEP;

            pm.x += pm.v_x * TIMESTEP * CANVAS_WIDTH;
            pm.y += pm.v_y * TIMESTEP * CANVAS_WIDTH;

            check_collisions(pm);
          })
        }

        function controls(pm) {
          // Correct for faster diagonal movement
          // Sum of vectors must be same as in case where moving along one axis
          // so each is scaled by 1/sqrt(2)
          var step_CONTROL_FORCE = pm.CONTROL_FORCE;

          if ((keydown.left || keydown.right) && (keydown.up || keydown.down)){
            step_CONTROL_FORCE *= 0.70710678118;
          }

          // Movement controls
          if(keydown.left) {
            pm.F_x -= step_CONTROL_FORCE;
          }

          if(keydown.right) {
            pm.F_x += step_CONTROL_FORCE;
          }

          if(keydown.up) {
            pm.F_y -= step_CONTROL_FORCE;
          }

          if(keydown.down) {
            pm.F_y += step_CONTROL_FORCE;
          }
        }

        function physics(pm){
          // Gravity
          pm.F_y += GRAVITY*pm.mass;

          // Drag
          pm.F_x -= pm.v_x * pm.drag_coefficient;
          pm.F_y -= pm.v_y * pm.drag_coefficient;
        }

        function check_collisions(pm) {
          if (pm.x < 0 || pm.x > CANVAS_WIDTH){
            pm.v_x *= -pm.elasticity;
          }

          if (pm.y < 0 || pm.y > CANVAS_HEIGHT){
            pm.v_y *= -pm.elasticity;
          }

          // Enforce existence in game area by rebounding
          if (pm.x < 0){
            pm.x = 0 - pm.elasticity*(pm.x - 0);
          } else if (pm.x > CANVAS_WIDTH){
            pm.x = CANVAS_WIDTH - pm.elasticity*(pm.x - CANVAS_WIDTH);
          }

          if (pm.y < 0){
            pm.y = 0 - pm.elasticity*(pm.y - 0);
          } else if (pm.y > CANVAS_HEIGHT){
            pm.y = CANVAS_HEIGHT - pm.elasticity*(pm.y - CANVAS_HEIGHT);
          }
        }

        function draw() {
          canvas.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          canvas.globalAlpha = 1;
          canvas.strokeRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          canvas.font="20px Courier";
          canvas.fillText(`FPS: ${FPS}`, 0.9*CANVAS_WIDTH, 0.05*CANVAS_HEIGHT);

          canvas.globalAlpha = PM_ALPHA;
          pointMasses.forEach(function(pm){
            pm.draw();
          })

          canvas.globalAlpha = SPRING_ALPHA;
          springs.forEach(function(sp){
            sp.draw();
          })
        }

      //]]>
    </script>
  </body>
</html>
